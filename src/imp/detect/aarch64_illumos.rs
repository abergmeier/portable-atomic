// SPDX-License-Identifier: Apache-2.0 OR MIT

/*
Run-time CPU feature detection on AArch64 illumos by using getisax.

As of nightly-2024-09-07, is_aarch64_feature_detected doesn't support run-time detection on illumos.
https://github.com/rust-lang/stdarch/blob/d9466edb4c53cece8686ee6e17b028436ddf4151/crates/std_detect/src/detect/mod.rs

Run-time detection on AArch64 illumos is currently disabled by default as AArch64 port is experimental.
*/

include!("common.rs");

// core::ffi::c_* (except c_void) requires Rust 1.64, libc 1.0 plans to require Rust 1.63
#[allow(non_camel_case_types)]
mod ffi {
    pub(crate) use super::c_types::c_uint;

    sys_const!({
        // Defined in sys/auxv_aarch64.h.
        // https://github.com/richlowe/illumos-gate/blob/arm64-gate/usr/src/uts/common/sys/auxv_aarch64.h
        pub(crate) const AV_AARCH64_LSE: u32 = 1 << 15;
        pub(crate) const AV_AARCH64_2_LSE2: u32 = 1 << 2;
    });

    extern "C" {
        // Defined in sys/auxv.h.
        // https://illumos.org/man/2/getisax
        // https://github.com/richlowe/illumos-gate/blob/arm64-gate/usr/src/uts/common/sys/auxv.h
        pub(crate) fn getisax(array: *mut u32, n: c_uint) -> c_uint;
    }
}

#[cold]
fn _detect(info: &mut CpuInfo) {
    const OUT_LEN: ffi::c_uint = 2;
    let mut out = [0_u32; OUT_LEN as usize];
    // SAFETY: the pointer is valid because we got it from a reference.
    unsafe {
        ffi::getisax(out.as_mut_ptr(), OUT_LEN);
    }
    if out[0] & ffi::AV_AARCH64_LSE != 0 {
        info.set(CpuInfo::HAS_LSE);
    }
    if out[1] & ffi::AV_AARCH64_2_LSE2 != 0 {
        info.set(CpuInfo::HAS_LSE2);
    }
}

#[allow(
    clippy::alloc_instead_of_core,
    clippy::std_instead_of_alloc,
    clippy::std_instead_of_core,
    clippy::undocumented_unsafe_blocks,
    clippy::wildcard_imports
)]
#[cfg(test)]
mod tests {
    use super::*;

    // Static assertions for FFI bindings.
    // This checks that FFI bindings defined in this crate, FFI bindings defined
    // in libc, and FFI bindings generated for the platform's latest header file
    // using bindgen have compatible signatures.
    // Since this is static assertion, we can detect problems with
    // `cargo check --tests --target <target>` run in CI (via TESTS=1 build.sh)
    // without actually running tests on these platforms.
    // As for constants, they are checked by static assertions generated by sys_const!.
    // See also https://github.com/taiki-e/test-helper/blob/HEAD/tools/codegen/src/ffi.rs.
    // TODO(codegen): auto-generate this test
    #[allow(clippy::no_effect_underscore_binding)]
    const _: fn() = || {
        use test_helper::sys;
        let mut _getisax: unsafe extern "C" fn(*mut u32, ffi::c_uint) -> ffi::c_uint = ffi::getisax;
        _getisax = libc::getisax;
        _getisax = sys::getisax;
    };
}
